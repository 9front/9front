\section{\module{modulefinder} ---
         Find modules used by a script}
\sectionauthor{A.M. Kuchling}{amk@amk.ca}

\declaremodule{standard}{modulefinder}
\modulesynopsis{Find modules used by a script.}

\versionadded{2.3}

This module provides a \class{ModuleFinder} class that can be used to
determine the set of modules imported by a script.
\code{modulefinder.py} can also be run as a script, giving the
filename of a Python script as its argument, after which a report of
the imported modules will be printed.

\begin{funcdesc}{AddPackagePath}{pkg_name, path}
Record that the package named \var{pkg_name} can be found in the specified \var{path}.
\end{funcdesc}

\begin{funcdesc}{ReplacePackage}{oldname, newname}
Allows specifying that the module named \var{oldname} is in fact
the package named \var{newname}.  The most common usage would be 
to handle how the \module{_xmlplus} package replaces the \module{xml}
package.
\end{funcdesc}

\begin{classdesc}{ModuleFinder}{\optional{path=None, debug=0, excludes=[], replace_paths=[]}}

This class provides \method{run_script()} and \method{report()}
methods to determine the set of modules imported by a script.
\var{path} can be a list of directories to search for modules; if not
specified, \code{sys.path} is used. 
\var{debug} sets the debugging level; higher values make the class print 
debugging messages about what it's doing.
\var{excludes} is a list of module names to exclude from the analysis.
\var{replace_paths} is a list of \code{(\var{oldpath}, \var{newpath})}
tuples that will be replaced in module paths.
\end{classdesc}

\begin{methoddesc}[ModuleFinder]{report}{}
Print a report to standard output that lists the modules imported by the script
and their
paths, as well as modules that are missing or seem to be missing.
\end{methoddesc}

\begin{methoddesc}[ModuleFinder]{run_script}{pathname}
Analyze the contents of the \var{pathname} file, which must contain 
Python code.
\end{methoddesc}
 

